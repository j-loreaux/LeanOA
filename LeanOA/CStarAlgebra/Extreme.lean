import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Abs
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.Convex.Extreme
import LeanOA.ForMathlib.Misc

open Set Metric
open scoped ComplexStarModule

@[simp]
lemma realPart_one {A : Type*} [Ring A] [StarRing A] [Module â„‚ A] [StarModule â„‚ A] :
    â„œ (1 : A) = 1 := by
  ext; simp [realPart_apply_coe, â† two_smul â„]

@[simp]
lemma Set.extremePoints_Icc {a b : â„} (hab : a â‰¤ b) :
    Set.extremePoints â„ (Icc a b) = {a, b} := by
  ext x
  rw [convex_Icc .. |>.mem_extremePoints_iff_convex_diff]
  constructor
  Â· intro âŸ¨hâ‚, hâ‚‚âŸ©
    have := eq_endpoints_or_mem_Ioo_of_mem_Icc hâ‚
    suffices x âˆ‰ Ioo a b by grind
    intro hx
    have := hâ‚‚.isPreconnected.Icc_subset (a := a) (b := b) (by grind) (by grind)
    grind
  Â· simp only [mem_insert_iff, mem_singleton_iff, mem_Icc]
    rintro (rfl | rfl)
    Â· simpa using âŸ¨hab, convex_Ioc ..âŸ©
    Â· simpa using âŸ¨hab, convex_Ico ..âŸ©

@[nontriviality]
def Set.extremePoints_eq_univ {ğ•œ E : Type*} [Semiring ğ•œ] [PartialOrder ğ•œ]
    [AddCommMonoid E] [SMul ğ•œ E] [Subsingleton E] (A : Set E) :
    Set.extremePoints ğ•œ A = A :=
  subset_antisymm extremePoints_subset fun _ h â†¦ âŸ¨h, fun _ _ _ _ _ â†¦ Subsingleton.elim ..âŸ©

open Complex
lemma cfc_re_id {A : Type*} [CStarAlgebra A] {a : A} [IsStarNormal a] :
    cfc (re Â· : â„‚ â†’ â„‚) a = â„œ a := by
  conv_rhs => rw [realPart_apply_coe, â† cfc_id' â„‚ a, â† cfc_star, â† cfc_add .., â† cfc_smul ..]
  refine cfc_congr fun x hx â†¦ ?_
  rw [Complex.re_eq_add_conj, â† smul_one_smul â„‚ 2â»Â¹]
  simp [div_eq_inv_mul]

open Complex
lemma cfc_im_id {A : Type*} [CStarAlgebra A] {a : A} [IsStarNormal a] :
    cfc (im Â· : â„‚ â†’ â„‚) a = â„‘ a := by
  suffices cfc (fun z : â„‚ â†¦ re z + I * im z) a = â„œ a + I â€¢ â„‘ a by
    rw [cfc_add .., cfc_const_mul .., cfc_re_id] at this
    simpa
  simp [mul_comm I, re_add_im, cfc_id' .., realPart_add_I_smul_imaginaryPart]

lemma star_mul_self_eq_realPart_sq_add_imaginaryPart_sq
    {A : Type*} [NonUnitalRing A] [StarRing A]
    [Module â„‚ A] [SMulCommClass â„‚ A A] [IsScalarTower â„‚ A A] [StarModule â„‚ A]
    {x : A} [hx : IsStarNormal x] :
    star x * x = realPart x * realPart x + imaginaryPart x * imaginaryPart x := by
  -- seriously? we have to do this?
  have : IsAddTorsionFree A :=  have : Module â„š A := RestrictScalars.module â„š â„ A; .of_module_rat A
  apply nsmul_right_injective two_ne_zero
  simp only
  nth_rw 1 [two_nsmul, star_comm_self' x, add_comm, star_mul_self_add_self_mul_star]

lemma CStarAlgebra.one_mem_extremePoints_closedUnitBall {A : Type*} [CStarAlgebra A] :
    1 âˆˆ extremePoints â„ (closedBall (0 : A) 1) := by
  nontriviality A
  /- Suppose that `1` is a convex combination of `x` and `y`. Then, since `1` is self
  adjoint, it is also a combination of their real and imaginary parts, which we
  call `a` and `b`. Moreover, `b` is in the Câ‹†-subalgebra generated by `a`, so we
  may write it as the continuous functional calculus applied to the appropriate
  function of `a`. -/
  refine âŸ¨by simp, fun x hx y hy hxy â†¦ ?_âŸ©
  let +nondep (eq := ha') a : A := â„œ x
  let +nondep (eq := hb') b : A := â„œ y
  simp only [mem_closedBall, dist_zero_right] at hx hy
  have ha : â€–aâ€– â‰¤ 1 := by simpa [ha'] using realPart.norm_le _ |>.trans hx
  have hb : â€–bâ€– â‰¤ 1 := by simpa [hb'] using realPart.norm_le _ |>.trans hy
  obtain âŸ¨câ‚, hcâ‚, câ‚‚, hcâ‚‚, hc, hcxyâŸ© := by simpa [openSegment] using hxy
  have hcab : câ‚ â€¢ a + câ‚‚ â€¢ b = 1 := by simpa [ha', hb'] using congr((â„œ $hcxy : A))
  have : b = câ‚‚â»Â¹ â€¢ 1 - câ‚‚â»Â¹ â€¢ câ‚ â€¢ a := by
    simpa [inv_smul_smulâ‚€ hcâ‚‚.ne', eq_sub_iff_add_eq'] using congr(câ‚‚â»Â¹ â€¢ $hcab)
  rw [this, â† cfc_id' â„ a, â† cfc_one â„ a] at hcab
  rw [â† cfc_smul .., â† cfc_smul .., â† cfc_smul ..,
    â† cfc_sub .., â† cfc_smul .., â† cfc_add .., cfc_eq_cfc_iff_eqOn] at hcab
  obtain rfl : a = 1 := by
    refine CFC.eq_one_of_spectrum_subset_one (R := â„) a fun r hr â†¦ ?_
    have keyâ‚€ := hcab hr
    simp only [smul_eq_mul, Pi.one_apply, mul_one, â† mul_assoc] at keyâ‚€
    have key : (1 : â„) âˆˆ openSegment â„ r (câ‚‚â»Â¹ - câ‚‚â»Â¹ * câ‚ * r) :=
      âŸ¨câ‚, câ‚‚, hcâ‚, hcâ‚‚, hc, by simpa [mul_assoc] using hcab hrâŸ©
    have keyâ‚‚ : (1 : â„) âˆˆ extremePoints â„ (Icc (-1) 1) := by simp
    simp only [mem_singleton_iff]
    refine mem_extremePoints_iff_left.mp keyâ‚‚ |>.2 _ ?_ _ ?_ key
    Â· simpa [abs_le] using (spectrum.norm_le_norm_of_mem hr).trans ha
    Â· suffices câ‚‚â»Â¹ - câ‚‚â»Â¹ * câ‚ * r âˆˆ spectrum â„ b by
        simpa [abs_le] using (spectrum.norm_le_norm_of_mem this).trans hb
      rw [this, â† Algebra.algebraMap_eq_smul_one, sub_eq_add_neg, sub_eq_add_neg]
      rwa [add_comm câ‚‚â»Â¹, spectrum.add_mem_add_iff, â† spectrum.neg_eq, Set.neg_mem_neg, smul_smul,
        spectrum.smul_eq_smul _ _ (nonempty_of_mem hr), â† smul_eq_mul _ r,
        Set.smul_mem_smul_set_iffâ‚€ (by positivity)]
  obtain rfl : b = 1 := by
    simpa [â† smul_assoc, â† sub_smul, (sub_eq_iff_eq_add.mpr hc.symm).symm, mul_sub, hcâ‚‚.ne']
  clear this hb ha hcab hb' hcxy hc hcâ‚‚ hcâ‚ câ‚ câ‚‚ hy hxy y
  have hx' : IsStarNormal x := by simp [isStarNormal_iff_commute_realPart_imaginaryPart, â† ha']
  suffices (â„‘ x : A) = 0 by rw [â† realPart_add_I_smul_imaginaryPart x, â† ha', this]; simp
  letI := spectralOrder A
  letI := spectralOrderedRing A
  rw [â† sq_le_one_iffâ‚€ (by positivity), sq, â† CStarRing.norm_star_mul_self,
    star_mul_self_eq_realPart_sq_add_imaginaryPart_sq, â† ha', mul_one, â† sq,
    CStarAlgebra.norm_le_one_iff_of_nonneg _ (add_nonneg zero_le_one (â„‘ x).2.sq_nonneg)] at hx
  rw [â† norm_eq_zero, â† sq_eq_zero_iff, â† IsSelfAdjoint.norm_mul_self (â„‘ x).2, â† sq, norm_eq_zero]
  exact le_antisymm (by simpa using hx) (â„‘ x).2.sq_nonneg
