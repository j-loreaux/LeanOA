import LeanOA.ForMathlib.Analysis.CStarAlgebra.Basic
import LeanOA.ForMathlib.Analysis.CStarAlgebra.Spectrum
import LeanOA.ForMathlib.Analysis.Complex.Basic
import LeanOA.ForMathlib.Data.Complex.Norm
import LeanOA.ForMathlib.Data.Complex.Order
import LeanOA.ForMathlib.Misc
import LeanOA.ForMathlib.Topology.Algebra.Star.Unitary
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Continuity
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unitary
import Mathlib.Analysis.CStarAlgebra.Exponential
import Mathlib.Analysis.SpecialFunctions.Complex.Circle
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog

/-! # Properties of unitary elements in a C‚ãÜ-algebra

## Main results

+ `CStarAlgebra.exists_sum_four_unitary`: every element `x` in a unital C‚ãÜ-algebra is a linear
  combination of four unitary elements, and the norm of each coefficient does not exceed `‚Äñx‚Äñ / 2`.
+ `CStarAlgebra.span_unitary`: a unital C‚ãÜ-algebra is spanned by its unitary elements.
+ `unitary.argSelfAdjoint`: the selfadjoint element obtained by taking the argument (using the
  principal branch and the continuous functional calculus) of a unitary. This returns `0` if
  the principal branch of the logarithm is not continuous on the spectrum of the unitary element.
+ `selfAdjoint.norm_sq_expUnitary_sub_one`:
  `‚Äñ(selfAdjoint.expUnitary x - 1 : A)‚Äñ ^ 2 = 2 * (1 - Real.cos ‚Äñx‚Äñ)`
+ `unitary.norm_argSelfAdjoint`:
  `‚Äñunitary.argSelfAdjoint u‚Äñ = Real.arccos (1 - ‚Äñ(u - 1 : A)‚Äñ ^ 2 / 2)`
+ `unitary.partialHomeomorph`: the maps `unitary.argSelfAdjoint` and `selfAdjoint.expUnitary` form
  a partial homeomorphism between `ball (1 : unitary A) 2` and `ball (0 : selfAdjoint A) œÄ`.
+ `selfAdjoint.expUnitary_pathToOne`: the path `t ‚Ü¶ expUnitary (t ‚Ä¢ x)` from `1` to
  `expUnitary x` for a selfadjoint element `x`.
+ `unitary.isPathConnected_ball`: any ball of radius `Œ¥ < 2` in the unitary group of a unital
  C‚ãÜ-algebra is path connected.
+ `unitary.instLocPathConnectedSpace`: the unitary group of a C‚ãÜ-algebra is locally path connected.
+ `unitary.mem_pathComponentOne_iff`: The path component of the identity in the unitary group of a
  C‚ãÜ-algebra is the set of unitaries that can be expressed as a product of exponentials of
  selfadjoint elements.
-/

variable {A : Type*} [CStarAlgebra A]

section UnitarySpan

open scoped ComplexStarModule
open Complex

section Ordered

variable [PartialOrder A] [StarOrderedRing A]

/-- If `a : A` is a selfadjoint element in a C‚ãÜ-algebra with `‚Äña‚Äñ ‚â§ 1`,
then `a + I ‚Ä¢ CFC.sqrt (1 - a ^ 2)` is unitary.

This is the key tool to show that a C‚ãÜ-algebra is spanned by its unitary elements. -/
lemma IsSelfAdjoint.self_add_I_smul_cfcSqrt_sub_sq_mem_unitary (a : A) (ha : IsSelfAdjoint a)
    (ha_norm : ‚Äña‚Äñ ‚â§ 1) : a + I ‚Ä¢ CFC.sqrt (1 - a ^ 2) ‚àà unitary A := by
  obtain (_ | _) := subsingleton_or_nontrivial A
  ¬∑ simp [Subsingleton.elim (a + I ‚Ä¢ CFC.sqrt (1 - a ^ 2)) 1, one_mem (unitary A)]
  have key : a + I ‚Ä¢ CFC.sqrt (1 - a ^ 2) = cfc (fun x : ‚ÑÇ ‚Ü¶ x.re + I * ‚àö(1 - x.re ^ 2)) a := by
    rw [CFC.sqrt_eq_real_sqrt (1 - a ^ 2) ?nonneg]
    case nonneg =>
      rwa [sub_nonneg, ‚Üê CStarAlgebra.norm_le_one_iff_of_nonneg (a ^ 2), ha.sq_norm,
        sq_le_one_iff‚ÇÄ (by positivity)]
    -- I *really* want this to be solved with a `cfc_pull` tactic. This is a good example of a stress test.
    rw [cfc_add .., cfc_const_mul .., ‚Üê cfc_real_eq_complex (fun x ‚Ü¶ x) ha, cfc_id' ‚Ñù a,
      ‚Üê cfc_real_eq_complex (fun x ‚Ü¶ ‚àö(1 - x ^2)) ha, cfc‚Çô_eq_cfc, cfc_comp' (‚àö¬∑) (1 - ¬∑ ^ 2) a,
      cfc_sub .., cfc_pow .., cfc_const_one .., cfc_id' ..]
  rw [key, cfc_unitary_iff ..]
  intro x hx
  rw [‚Üê starRingEnd_apply, ‚Üê Complex.normSq_eq_conj_mul_self,
    Complex.normSq_ofReal_add_I_smul_sqrt_one_sub, Complex.ofReal_one]
  exact spectrum.norm_le_norm_of_mem (ha.spectrumRestricts.apply_mem hx) |>.trans ha_norm

/-- For `a` selfadjoint with `‚Äña‚Äñ ‚â§ 1`, this is the unitary `a + I ‚Ä¢ ‚àö(1 - a ^ 2)`. -/
@[simps]
noncomputable def selfAdjoint.unitarySelfAddISMul (a : selfAdjoint A)
    (ha_norm : ‚Äña‚Äñ ‚â§ 1) :
    unitary A :=
  ‚ü®(a : A) + I ‚Ä¢ CFC.sqrt (1 - a ^ 2 : A), a.2.self_add_I_smul_cfcSqrt_sub_sq_mem_unitary _ ha_norm‚ü©

lemma selfAdjoint.star_coe_unitarySelfAddISMul (a : selfAdjoint A) (ha_norm : ‚Äña‚Äñ ‚â§ 1) :
    (star (unitarySelfAddISMul a ha_norm) : A) = a - I ‚Ä¢ CFC.sqrt (1 - a ^ 2 : A) := by
  simp [a.2, IsSelfAdjoint.star_eq, ‚Üê sub_eq_add_neg,
    IsSelfAdjoint.of_nonneg (CFC.sqrt_nonneg (a := (1 - a ^ 2 : A)))]

lemma selfAdjoint.realPart_unitarySelfAddISMul (a : selfAdjoint A) (ha_norm : ‚Äña‚Äñ ‚â§ 1) :
    ‚Ñú (unitarySelfAddISMul a ha_norm : A) = a := by
  simp [IsSelfAdjoint.imaginaryPart (x := CFC.sqrt (1 - a ^ 2 : A)) (by cfc_tac)]

/-- A stepping stone to `CStarAlgebra.exists_sum_four_unitary` that specifies the unitary
elements precisely. The `let`s in the statement are intentional. -/
lemma CStarAlgebra.norm_smul_two_inv_smul_add_four_unitary (x : A) (hx : x ‚â† 0) :
    let u‚ÇÅ : unitary A := selfAdjoint.unitarySelfAddISMul (‚Ñú (‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x))
      (by simpa [norm_smul, inv_mul_le_one‚ÇÄ (norm_pos_iff.2 hx)] using realPart.norm_le x)
    let u‚ÇÇ : unitary A := selfAdjoint.unitarySelfAddISMul (‚Ñë (‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x))
      (by simpa [norm_smul, inv_mul_le_one‚ÇÄ (norm_pos_iff.2 hx)] using imaginaryPart.norm_le x)
    x = ‚Äñx‚Äñ ‚Ä¢ (2‚Åª¬π : ‚Ñù) ‚Ä¢ (u‚ÇÅ + star u‚ÇÅ + I ‚Ä¢ (u‚ÇÇ + star u‚ÇÇ) : A) := by
  intro u‚ÇÅ u‚ÇÇ
  rw [smul_add, smul_comm _ I, unitary.coe_star, unitary.coe_star,
    ‚Üê realPart_apply_coe (u‚ÇÅ : A), ‚Üê realPart_apply_coe (u‚ÇÇ : A)]
  simp only [u‚ÇÅ, u‚ÇÇ, selfAdjoint.realPart_unitarySelfAddISMul,
    realPart_add_I_smul_imaginaryPart, norm_smul_norm_inv_smul]

end Ordered

/-- Every element `x` in a unital C‚ãÜ-algebra is a linear combination of four unitary elements,
and the norm of each coefficient does not exceed `‚Äñx‚Äñ / 2`. -/
lemma CStarAlgebra.exists_sum_four_unitary (x : A) :
    ‚àÉ u : Fin 4 ‚Üí unitary A, ‚àÉ c : Fin 4 ‚Üí ‚ÑÇ, x = ‚àë i, c i ‚Ä¢ (u i : A) ‚àß ‚àÄ i, ‚Äñc i‚Äñ ‚â§ ‚Äñx‚Äñ / 2 := by
  let _ := CStarAlgebra.spectralOrder
  let _ := CStarAlgebra.spectralOrderedRing
  obtain (rfl | hx) := eq_or_ne x 0
  ¬∑ exact ‚ü®![1, -1, 1, -1], 0, by simp‚ü©
  ¬∑ have := norm_smul_two_inv_smul_add_four_unitary x hx
    extract_lets u‚ÇÅ u‚ÇÇ at this
    use ![u‚ÇÅ, star u‚ÇÅ, u‚ÇÇ, star u‚ÇÇ]
    use ![‚Äñx‚Äñ * 2‚Åª¬π, ‚Äñx‚Äñ * 2‚Åª¬π, ‚Äñx‚Äñ * 2‚Åª¬π * I, ‚Äñx‚Äñ * 2‚Åª¬π * I]
    constructor
    ¬∑ conv_lhs => rw [this]
      simp [Fin.sum_univ_four, ‚Üê Complex.coe_smul]
      module
    ¬∑ intro i
      fin_cases i
      all_goals simp [div_eq_mul_inv]

variable (A) in
open Submodule in
/-- A unital C‚ãÜ-algebra is spanned by its unitary elements. -/
lemma CStarAlgebra.span_unitary : span ‚ÑÇ (unitary A : Set A) = ‚ä§ := by
  rw [eq_top_iff]
  rintro x -
  obtain ‚ü®u, c, rfl, h‚ü© := CStarAlgebra.exists_sum_four_unitary x
  exact sum_mem fun i _ ‚Ü¶ smul_mem _ _ (subset_span (u i).2)

end UnitarySpan

section ExpUnitary

variable {A : Type*} [CStarAlgebra A]

open Complex Metric NormedSpace selfAdjoint unitary
open scoped Real

lemma unitary.two_mul_one_sub_le_norm_sub_one_sq {u : A} (hu : u ‚àà unitary A)
    {z : ‚ÑÇ} (hz : z ‚àà spectrum ‚ÑÇ u) :
    2 * (1 - z.re) ‚â§ ‚Äñu - 1‚Äñ ^ 2 := by
  rw [‚Üê Real.sqrt_le_left (by positivity)]
  have := spectrum.subset_circle_of_unitary hu hz
  simp only [mem_sphere_iff_norm, sub_zero] at this
  rw [‚Üê cfc_id' ‚ÑÇ u, ‚Üê cfc_one ‚ÑÇ u, ‚Üê cfc_sub ..]
  convert norm_apply_le_norm_cfc (fun z ‚Ü¶ z - 1) u hz
  simpa using congr(Real.sqrt $(norm_sub_one_sq_eq_of_norm_one this)).symm

lemma unitary.norm_sub_one_sq_eq {u : A} (hu : u ‚àà unitary A) {x : ‚Ñù}
    (hz : IsLeast (re '' (spectrum ‚ÑÇ u)) x) :
    ‚Äñu - 1‚Äñ ^ 2 = 2 * (1 - x) := by
  obtain (_ | _) := subsingleton_or_nontrivial A
  ¬∑ exfalso; apply hz.nonempty.of_image.ne_empty; simp
  rw [‚Üê cfc_id' ‚ÑÇ u, ‚Üê cfc_one ‚ÑÇ u, ‚Üê cfc_sub ..]
  have h_eqOn : (spectrum ‚ÑÇ u).EqOn (fun z ‚Ü¶ ‚Äñz - 1‚Äñ ^ 2) (fun z ‚Ü¶ 2 * (1 - z.re)) :=
    Complex.norm_sub_one_sq_eqOn_sphere.mono <| spectrum.subset_circle_of_unitary (ùïú := ‚ÑÇ) hu
  have h‚ÇÇ : IsGreatest ((fun z ‚Ü¶ 2 * (1 - z.re)) '' (spectrum ‚ÑÇ u)) (2 * (1 - x)) := by
    have : Antitone (fun y : ‚Ñù ‚Ü¶ 2 * (1 - y)) := by intro _ _ _; simp only; gcongr
    simpa [Set.image_image] using this.map_isLeast hz
  have h‚ÇÉ : IsGreatest ((‚Äñ¬∑ - 1‚Äñ ^ 2) '' spectrum ‚ÑÇ u) (‚Äñcfc (¬∑ - 1 : ‚ÑÇ ‚Üí ‚ÑÇ) u‚Äñ ^ 2) := by
    have := pow_left_monotoneOn (n := 2) |>.mono (s‚ÇÇ := ((‚Äñ¬∑ - 1‚Äñ) '' spectrum ‚ÑÇ u)) (by aesop)
    simpa [Set.image_image] using this.map_isGreatest (IsGreatest.norm_cfc (fun z : ‚ÑÇ ‚Ü¶ z - 1) u)
  exact h‚ÇÉ.unique (h_eqOn.image_eq ‚ñ∏ h‚ÇÇ)

lemma unitary.norm_sub_one_lt_two_iff {u : A} (hu : u ‚àà unitary A) :
    ‚Äñu - 1‚Äñ < 2 ‚Üî -1 ‚àâ spectrum ‚ÑÇ u := by
  nontriviality A
  rw [‚Üê sq_lt_sq‚ÇÄ (by positivity) (by positivity)]
  constructor
  ¬∑ intro h h1
    have := two_mul_one_sub_le_norm_sub_one_sq hu h1 |>.trans_lt h
    norm_num at this
  ¬∑ contrapose!
    obtain ‚ü®x, hx‚ü© := spectrum.isCompact (ùïú := ‚ÑÇ) u |>.image continuous_re |>.exists_isLeast <| (spectrum.nonempty _).image _
    rw [norm_sub_one_sq_eq hu hx]
    obtain ‚ü®z, hz, rfl‚ü© := hx.1
    intro key
    replace key : z.re ‚â§ -1 := by linarith
    have hz_norm : ‚Äñz‚Äñ = 1 := spectrum.norm_eq_one_of_unitary hu hz
    rw [‚Üê hz_norm, Complex.re_le_neg_norm_iff_eq_neg_norm, hz_norm] at key
    exact key ‚ñ∏ hz

lemma unitary.spectrum_subset_slitPlane_of_norm_lt_two {u : A} (hu : u ‚àà unitary A)
    (hu_norm : ‚Äñu - 1‚Äñ < 2) :
    spectrum ‚ÑÇ u ‚äÜ slitPlane:= by
  intro z hz
  rw [mem_slitPlane_iff]
  have hz_norm : ‚Äñz‚Äñ = 1 := spectrum.norm_eq_one_of_unitary hu hz
  have := sq_eq_one_iff.mpr <| .inl hz_norm
  rw [‚Üê normSq_eq_norm_sq, normSq_apply] at this
  by_cases h : z.im = 0
  ¬∑ simp [h, ‚Üê sq] at this
    cases this with
    | inl h => simp [h]
    | inr h =>
      have := hz_norm ‚ñ∏ h.le
      rw [Complex.re_le_neg_norm_iff_eq_neg_norm, hz_norm, ofReal_one] at this
      rw [norm_sub_one_lt_two_iff hu] at hu_norm
      exact False.elim <| hu_norm (this ‚ñ∏ hz)
  ¬∑ exact .inr h

@[aesop safe apply (rule_sets := [CStarAlgebra])]
lemma IsSelfAdjoint.cfc_arg (u : A) : IsSelfAdjoint (cfc (ofReal ‚àò arg : ‚ÑÇ ‚Üí ‚ÑÇ) u) := by
  simp [isSelfAdjoint_iff, ‚Üê cfc_star, Function.comp_def]

/-- The selfadjoint element obtained by taking the argument (using the principal branch and the
continuous functional calculus) of a unitary whose spectrum does not contain `-1`. This returns
`0` if the principal branch of the logarithm is not continuous on the spectrum of the unitary
element. -/
@[simps]
noncomputable def unitary.argSelfAdjoint (u : unitary A) : selfAdjoint A :=
  ‚ü®cfc (arg ¬∑ : ‚ÑÇ ‚Üí ‚ÑÇ) (u : A), .cfc_arg (u : A)‚ü©

lemma selfAdjoint.norm_sq_expUnitary_sub_one {x : selfAdjoint A} (hx : ‚Äñx‚Äñ ‚â§ œÄ) :
    ‚Äñ(expUnitary x - 1 : A)‚Äñ ^ 2 = 2 * (1 - Real.cos ‚Äñx‚Äñ) := by
  nontriviality A
  apply norm_sub_one_sq_eq (expUnitary x).2
  simp only [expUnitary_coe, AddSubgroupClass.coe_norm]
  rw [‚Üê CFC.exp_eq_normedSpace_exp, ‚Üê cfc_comp_smul I _ (x : A), cfc_map_spectrum .., ‚Üê x.2.spectrumRestricts.algebraMap_image]
  simp only [Set.image_image, coe_algebraMap, smul_eq_mul, mul_comm I, ‚Üê exp_eq_exp_‚ÑÇ, exp_ofReal_mul_I_re]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ cases CStarAlgebra.norm_or_neg_norm_mem_spectrum x.2 with
    | inl h => exact ‚ü®_, h, rfl‚ü©
    | inr h => exact ‚ü®_, h, by simp‚ü©
  ¬∑ rintro - ‚ü®y, hy, rfl‚ü©
    exact Real.cos_abs y ‚ñ∏ Real.cos_le_cos_of_nonneg_of_le_pi (by positivity) hx <| spectrum.norm_le_norm_of_mem hy

lemma argSelfAdjoint_expUnitary {x : selfAdjoint A} (hx : ‚Äñx‚Äñ < œÄ) :
    argSelfAdjoint (expUnitary x) = x := by
  nontriviality A
  ext
  have : spectrum ‚ÑÇ (expUnitary x : A) ‚äÜ slitPlane := by
    apply spectrum_subset_slitPlane_of_norm_lt_two (expUnitary x).2
    rw [‚Üê sq_lt_sq‚ÇÄ (by positivity) (by positivity), norm_sq_expUnitary_sub_one hx.le]
    calc
      2 * (1 - Real.cos ‚Äñx‚Äñ) < 2 * (1 - Real.cos œÄ) := by
        gcongr
        exact Real.cos_lt_cos_of_nonneg_of_le_pi (by positivity) le_rfl hx
      _ = 2 ^ 2 := by norm_num
  simp only [argSelfAdjoint_coe, expUnitary_coe]
  rw [‚Üê CFC.exp_eq_normedSpace_exp, ‚Üê cfc_comp_smul .., ‚Üê cfc_comp' (hg := ?_)]
  ¬∑ conv_rhs => rw [‚Üê cfc_id' ‚ÑÇ (x : A)]
    refine cfc_congr fun y hy ‚Ü¶ ?_
    rw [‚Üê x.2.spectrumRestricts.algebraMap_image] at hy
    obtain ‚ü®y, hy, rfl‚ü© := hy
    simp [‚Üê exp_eq_exp_‚ÑÇ, exp_ofReal_mul_I_re, mul_comm I, ‚Üê ofReal_mul, exp_ofReal_mul_I_re]
    replace hy : ‚Äñy‚Äñ < œÄ := spectrum.norm_le_norm_of_mem hy |>.trans_lt hx
    simp only [Real.norm_eq_abs, abs_lt] at hy
    rw [‚Üê Circle.coe_exp, Circle.arg_exp hy.1 hy.2.le]
  refine continuous_ofReal.comp_continuousOn <| continuousOn_arg.mono ?_
  rwa [expUnitary_coe, ‚Üê CFC.exp_eq_normedSpace_exp, ‚Üê cfc_comp_smul .., cfc_map_spectrum ..] at this

lemma expUnitary_argSelfAdjoint {u : unitary A} (hu : ‚Äñ(u - 1 : A)‚Äñ < 2) :
    expUnitary (argSelfAdjoint u) = u := by
  ext
  have : ContinuousOn arg (spectrum ‚ÑÇ (u : A)) :=
    continuousOn_arg.mono <| spectrum_subset_slitPlane_of_norm_lt_two u.2 hu
  rw [expUnitary_coe, argSelfAdjoint_coe, ‚Üê CFC.exp_eq_normedSpace_exp, ‚Üê cfc_comp_smul .., ‚Üê cfc_comp' ..]
  conv_rhs => rw [‚Üê cfc_id' ‚ÑÇ (u : A)]
  refine cfc_congr fun y hy ‚Ü¶ ?_
  have hy‚ÇÅ : ‚Äñy‚Äñ = 1 := spectrum.norm_eq_one_of_unitary u.2 hy
  have : I * y.arg = log y :=
    Complex.ext (by simp [log_re, spectrum.norm_eq_one_of_unitary u.2 hy]) (by simp [log_im])
  simpa [‚Üê exp_eq_exp_‚ÑÇ, this] using exp_log (by aesop)

lemma unitary.norm_argSelfAdjoint_le_pi (u : unitary A) :
    ‚ÄñargSelfAdjoint u‚Äñ ‚â§ œÄ :=
  norm_cfc_le (by positivity) fun y hy ‚Ü¶ by simpa using abs_arg_le_pi y

lemma unitary.two_mul_one_sub_cos_norm_argSelfAdjoint {u : unitary A} (hu : ‚Äñ(u - 1 : A)‚Äñ < 2) :
    2 * (1 - Real.cos ‚ÄñargSelfAdjoint u‚Äñ) = ‚Äñ(u - 1 : A)‚Äñ ^ 2 := by
  conv_rhs => rw [‚Üê expUnitary_argSelfAdjoint hu]
  exact Eq.symm <| norm_sq_expUnitary_sub_one <| norm_argSelfAdjoint_le_pi u

lemma unitary.norm_argSelfAdjoint {u : unitary A} (hu : ‚Äñ(u - 1 : A)‚Äñ < 2) :
    ‚ÄñargSelfAdjoint u‚Äñ = Real.arccos (1 - ‚Äñ(u - 1 : A)‚Äñ ^ 2 / 2) := by
  refine Real.arccos_eq_of_eq_cos (by positivity) (norm_argSelfAdjoint_le_pi u) ?_ |>.symm
  linarith [two_mul_one_sub_cos_norm_argSelfAdjoint hu]

lemma unitary.norm_expUnitary_smul_argSelfAdjoint_sub_one_le (u : unitary A)
    {t : ‚Ñù} (ht : t ‚àà Set.Icc 0 1) (hu : ‚Äñ(u - 1 : A)‚Äñ < 2) :
    ‚Äñ(expUnitary (t ‚Ä¢ argSelfAdjoint u) - 1 : A)‚Äñ ‚â§ ‚Äñ(u - 1 : A)‚Äñ := by
  have key : ‚Äñt ‚Ä¢ argSelfAdjoint u‚Äñ ‚â§ ‚ÄñargSelfAdjoint u‚Äñ := by
    rw [‚Üê one_mul ‚ÄñargSelfAdjoint u‚Äñ]
    simp_rw [AddSubgroupClass.coe_norm, val_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg ht.1]
    gcongr
    exact ht.2
  rw [‚Üê sq_le_sq‚ÇÄ (by positivity) (by positivity)]
  rw [norm_sq_expUnitary_sub_one (key.trans <| norm_argSelfAdjoint_le_pi u)]
  trans 2 * (1 - Real.cos ‚ÄñargSelfAdjoint u‚Äñ)
  ¬∑ gcongr
    exact Real.cos_le_cos_of_nonneg_of_le_pi (by positivity) (norm_argSelfAdjoint_le_pi u) key
  ¬∑ exact (two_mul_one_sub_cos_norm_argSelfAdjoint hu).le

@[fun_prop]
lemma unitary.continuousOn_argSelfAdjoint :
    ContinuousOn (argSelfAdjoint : unitary A ‚Üí selfAdjoint A) (ball (1 : unitary A) 2) := by
  rw [Topology.IsInducing.subtypeVal.continuousOn_iff]
  simp [Function.comp_def]
  rw [isOpen_ball.continuousOn_iff]
  intro u (hu : dist u 1 < 2)
  obtain ‚ü®Œµ, huŒµ, hŒµ2‚ü© := exists_between (sq_lt_sq‚ÇÄ (by positivity) (by positivity) |>.mpr hu)
  have hŒµ : 0 < Œµ := lt_of_le_of_lt (by positivity) huŒµ
  have huŒµ' : dist u 1 < ‚àöŒµ := Real.lt_sqrt_of_sq_lt huŒµ
  apply ContinuousOn.continuousAt ?_ (closedBall_mem_nhds_of_mem huŒµ')
  apply ContinuousOn.image_comp_continuous ?_ continuous_subtype_val
  apply continuousOn_cfc A (s := sphere 0 1 ‚à© {z | 2 * (1 - z.re) ‚â§ Œµ}) ?_ _ ?_ |>.mono
  ¬∑ rintro - ‚ü®v, hv, rfl‚ü©
    simp only [Set.subset_inter_iff, Set.mem_setOf_eq]
    refine ‚ü®inferInstance, spectrum_subset_circle v, ?_‚ü©
    intro z hz
    simp only [Set.mem_setOf_eq]
    trans ‚Äñ(v - 1 : A)‚Äñ ^ 2
    ¬∑ exact two_mul_one_sub_le_norm_sub_one_sq v.2 hz
    ¬∑ refine Real.le_sqrt (by positivity) (by positivity) |>.mp ?_
      simpa [Subtype.dist_eq, dist_eq_norm] using hv
  ¬∑ exact isCompact_sphere 0 1 |>.inter_right <| isClosed_le (by fun_prop) (by fun_prop)
  ¬∑ refine continuous_ofReal.comp_continuousOn <| continuousOn_arg.mono ?_
    apply subset_slitPlane_of_subset_sphere Set.inter_subset_left
    norm_num at hŒµ2 ‚ä¢
    exact hŒµ2

/-- the maps `unitary.argSelfAdjoint` and `selfAdjoint.expUnitary` form a partial
homeomorphism between `ball (1 : unitary A) 2` and `ball (0 : selfAdjoint A) œÄ`. -/
@[simps]
noncomputable def unitary.partialHomeomorph :
    PartialHomeomorph (unitary A) (selfAdjoint A) where
  toFun := argSelfAdjoint
  invFun := expUnitary
  source := ball 1 2
  target := ball 0 œÄ
  map_source' u hu := by
    simp only [mem_ball, Subtype.dist_eq, OneMemClass.coe_one, dist_eq_norm, sub_zero] at hu ‚ä¢
    rw [norm_argSelfAdjoint hu]
    calc
      Real.arccos (1 - ‚Äñ(u - 1 : A)‚Äñ ^ 2 / 2) < Real.arccos (1 - 2 ^ 2 / 2) := by
        apply Real.arccos_lt_arccos (by norm_num) (by gcongr)
        linarith [(by positivity : 0 ‚â§ ‚Äñ(u - 1 : A)‚Äñ ^ 2 / 2)]
      _ = œÄ := by norm_num
  map_target' x hx := by
    simp only [mem_ball, Subtype.dist_eq, OneMemClass.coe_one, dist_eq_norm, sub_zero] at hx ‚ä¢
    rw [‚Üê sq_lt_sq‚ÇÄ (by positivity) (by positivity)]
    rw [norm_sq_expUnitary_sub_one hx.le]
    have : -1 < Real.cos ‚Äñ(x : A)‚Äñ :=
      Real.cos_pi ‚ñ∏ Real.cos_lt_cos_of_nonneg_of_le_pi (by positivity) le_rfl hx
    simp [mul_sub, sq]
    linarith
  left_inv' u hu := expUnitary_argSelfAdjoint <| by
    simpa [Subtype.dist_eq, dist_eq_norm] using hu
  right_inv' x hx := argSelfAdjoint_expUnitary <| by simpa using hx
  open_source := isOpen_ball
  open_target := isOpen_ball
  continuousOn_toFun := by fun_prop
  continuousOn_invFun := by fun_prop

lemma unitary.norm_sub_eq (u v : unitary A) :
    ‚Äñ(u - v : A)‚Äñ = ‚Äñ((u * star v : unitary A) - 1 : A)‚Äñ := calc
  ‚Äñ(u - v : A)‚Äñ = ‚Äñ(u * star v - 1 : A) * v‚Äñ := by simp [sub_mul, mul_assoc]
  _ = ‚Äñ((u * star v : unitary A) - 1 : A)‚Äñ := by simp

lemma unitary.expUnitary_eq_mul_inv (u v : unitary A) (huv : ‚Äñ(u - v : A)‚Äñ < 2) :
    expUnitary (argSelfAdjoint (u * star v)) = u * star v :=
  expUnitary_argSelfAdjoint <| norm_sub_eq u v ‚ñ∏ huv

/-- For a selfadjoint element `x` in a C‚ãÜ-algebra, this is the path from `1` to `expUnitary x`. -/
@[simps]
noncomputable def selfAdjoint.expUnitary_pathToOne (x : selfAdjoint A) :
    Path 1 (expUnitary x) where
  toFun t := expUnitary ((t : ‚Ñù) ‚Ä¢ x)
  continuous_toFun := by fun_prop
  source' := by simp
  target' := by simp

@[simp]
lemma selfAdjoint.joined_one_expUnitary (x : selfAdjoint A) :
    Joined (1 : unitary A) (expUnitary x) :=
  ‚ü®expUnitary_pathToOne x‚ü©

/-- The path `t ‚Ü¶ expUnitary (t ‚Ä¢ argSelfAdjoint (v * star u)) * u`
from `u : unitary A` to `v` when `‚Äñv - u‚Äñ < 2`. -/
@[simps]
noncomputable def unitary.path (u v : unitary A) (huv : ‚Äñ(v - u : A)‚Äñ < 2) :
    Path u v where
  toFun t := expUnitary ((t : ‚Ñù) ‚Ä¢ argSelfAdjoint (v * star u)) * u
  continuous_toFun := by fun_prop
  source' := by ext; simp
  target' := by simp [expUnitary_eq_mul_inv v u huv, mul_assoc]

lemma unitary.joined (u v : unitary A) (huv : ‚Äñ(v - u : A)‚Äñ < 2) :
    Joined u v :=
  ‚ü®path u v huv‚ü©

/-- Any ball of radius `Œ¥ < 2` in the unitary group of a unital C‚ãÜ-algebra is path connected. -/
lemma unitary.isPathConnected_ball (u : unitary A) (Œ¥ : ‚Ñù) (hŒ¥‚ÇÄ : 0 < Œ¥) (hŒ¥‚ÇÇ : Œ¥ < 2) :
    IsPathConnected (ball (u : unitary A) Œ¥) := by
  suffices IsPathConnected (ball (1 : unitary A) Œ¥) by
    convert this |>.image (f := (u * ¬∑)) (by fun_prop)
    ext v
    rw [‚Üê inv_mul_cancel u]
    simp [- inv_mul_cancel, Subtype.dist_eq, dist_eq_norm, ‚Üê mul_sub]
  refine ‚ü®1, by simpa, fun {u} hu ‚Ü¶ ?_‚ü©
  have hu : ‚Äñ(u - 1 : A)‚Äñ < Œ¥ := by simpa [Subtype.dist_eq, dist_eq_norm] using hu
  refine ‚ü®path 1 u (hu.trans hŒ¥‚ÇÇ), fun t ‚Ü¶ ?_‚ü©
  simpa [Subtype.dist_eq, dist_eq_norm] using
    norm_expUnitary_smul_argSelfAdjoint_sub_one_le u t.2 (hu.trans hŒ¥‚ÇÇ) |>.trans_lt hu

instance unitary.instLocPathConnectedSpace : LocPathConnectedSpace (unitary A) :=
  .of_bases (fun _ ‚Ü¶ nhds_basis_uniformity <| uniformity_basis_dist_lt zero_lt_two) <| by
    simpa using isPathConnected_ball

/-- The path component of the identity in the unitary group of a C‚ãÜ-algebra is the set of
unitaries that can be expressed as a product of exponentials of selfadjoint elements. -/
lemma unitary.mem_pathComponentOne_iff {u : unitary A} :
    u ‚àà pathComponent 1 ‚Üî ‚àÉ l : List (selfAdjoint A), (l.map expUnitary).prod = u := by
  constructor
  ¬∑ revert u
    simp_rw [‚Üê Set.mem_range, ‚Üê Set.subset_def, pathComponent_eq_connectedComponent]
    refine IsClopen.connectedComponent_subset ?_ ‚ü®[], by simp‚ü©
    refine .of_thickening_subset_self zero_lt_two ?_
    intro u hu
    rw [mem_thickening_iff] at hu
    obtain ‚ü®v, ‚ü®‚ü®l, (hlv : (l.map expUnitary).prod = v)‚ü©, huv‚ü©‚ü© := hu
    refine ‚ü®argSelfAdjoint (u * star v) :: l, ?_‚ü©
    simp [hlv, mul_assoc, expUnitary_eq_mul_inv u v (by simpa [Subtype.dist_eq, dist_eq_norm] using huv)]
  ¬∑ rintro ‚ü®l, rfl‚ü©
    induction l with
    | nil => simp
    | cons x xs ih => simpa using (joined_one_expUnitary x).mul ih

end ExpUnitary
